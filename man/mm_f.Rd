% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/mm_f.R
\name{mm_f}
\alias{mm_f}
\title{Filter projected data by rasterized map or numeric values and convert to data.frame.}
\usage{
mm_f(
  v,
  f = stds$mapField,
  c = "==",
  n = stds$mapNumber,
  x = get(stds$projectedRaster),
  y = stds$yValue,
  m = get(stds$rasterizedMaps),
  ...
)
}
\arguments{
\item{v}{Character or Numeric. Value of a specified field (f) of pixels that should be kept in the output.}

\item{f}{Character. Field name, containing the values, that should be kept. This can be field (layer) of m or x.}

\item{c}{Character. Condition, defining what should be done with pixels matching v. Standard is "==", which means keep. "!=" = keep all other, "<=" or similar can be used for numeric field content.}

\item{n}{Integer. The map needs to be provided as a list and n defines which map list entry should be used.}

\item{x}{SpatRaster, SpatVector or data.frame. Projected raster data.}

\item{y}{Character. Name of the field (layer) containing elevation values. This field will be named "y" in the output.}

\item{m}{SpatRaster. List of rasterized maps. Maps as created with mm_prepMap(). The resolution needs to be the same as of x.}

\item{...}{Arguments for mm_bab(). Standards are x = pro$line, width = para$sr and s for side of the profile to be filtered.}

\item{s}{Numeric. Choose to filter for right or left side of the profile line (1 or 2), or 3 both sides.}
}
\value{
data.frame
}
\description{
Requires terra packages
Takes SpatRaster or SpatVector of projected data (output of mm_prepRas() %>% mm_linRef()) and SpatRaster of rasterized map (output of mm_prepMap()) and arguments defining which pixels should be filtered. Output is a data.frame, which allows compatibility with PMT3 functions.
Output is a data.frame with x,y,z coordinates of the profile view and X,Y coordinates of the map view and slope values.
}
\examples{
DEM = mm_prepRas(profile = "notInPackage/testdata/profile.gpkg", searchRadius = 3000, raster = c("notInPackage/testdata/lidar.tif", "notInPackage/testdata/lidarFilled.tif"), analysisReso=100, makeSlope = T, makeShade = T);
DEMp = mm_linRef(p = ras, l = profile_line, addz = T, asVector = F);
map = mm_prpMap(map="notInPackage/testdata/terraceMap.gpkg",field="NAME_KURZ",cropper=profile_buffer,aligner=ras,asVector=T);
maps = list(map);

# stds is a helper, setting standard argument input for mm_f(), so values do not have to be typed each time.;
stds = list(projectedRaster = "DEMp", yValue = names(rasp)[1], rasterizedMaps = "maps", mapNumber = 1, mapField = "NAME_KURZ", orographicSide = 3);

# filter single mapped value;
mm_f("01_NT");

# filter more values, keeping both;
mm_f( c("01_NT", "02_HT") );

# filter by values in "slope", keeping all values <= than 2;
mm_f(2,"slope","<=");

# filter all pixels that are within mapped areas;
mm_f();

# convert full raster to data.frame;
mm_f(m=NA);

}
